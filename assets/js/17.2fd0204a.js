(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{332:function(t,s,a){"use strict";a.r(s);var v=a(33),e=Object(v.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"页面性能优化相关"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#页面性能优化相关"}},[t._v("#")]),t._v(" 页面性能优化相关")]),t._v(" "),a("p",[t._v("这边主要记述一些关于页面性能优化的一些相关知识点。")]),t._v(" "),a("h2",{attrs:{id:"资源请求与数据。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#资源请求与数据。"}},[t._v("#")]),t._v(" 资源请求与数据。")]),t._v(" "),a("p",[t._v("减少资源请求的次数和压缩数据内容")]),t._v(" "),a("p",[t._v("因为资源的请求是一个复杂的过程。网速相同的条件下，下载一个100KB的图片比下载两个50KB的图片要快。所以，请减少HTTP请求。")]),t._v(" "),a("p",[t._v("①进行资源打包，将需要多次请求的资源进行打包减少资源请求次数，如webpack等。")]),t._v(" "),a("p",[t._v("②使用雪碧图，可以避免因不同图片引起的多次资源下载")]),t._v(" "),a("h2",{attrs:{id:"高效的css选择符"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#高效的css选择符"}},[t._v("#")]),t._v(" 高效的css选择符")]),t._v(" "),a("p",[t._v("高效合理的css选择符可以减轻浏览器的解析负担")]),t._v(" "),a("p",[t._v("因为css是逆向解析的所以应当避免多层嵌套。")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("避免使用通配规则。如 *{} 计算次数惊人！只对需要用到的元素进行选择")])]),t._v(" "),a("li",[a("p",[t._v("尽量少的去对标签进行选择，而是用class。如：#nav li{},可以为li加上nav_item的类名，如下选择.nav_item{}")])]),t._v(" "),a("li",[a("p",[t._v("不要去用标签限定ID或者类选择符。如：ul#nav,应该简化为#nav")])]),t._v(" "),a("li",[a("p",[t._v("尽量少的去使用后代选择器，降低选择器的权重值。后代选择器的开销是最高的，尽量将选择器的深度降到最低，最高不要超过三层，更多的使用类来关联每一个标签元素。")])]),t._v(" "),a("li",[a("p",[t._v("考虑继承。了解哪些属性是可以通过继承而来的，然后避免对这些属性重复指定规则")])])]),t._v(" "),a("h2",{attrs:{id:"dns预解析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#dns预解析"}},[t._v("#")]),t._v(" DNS预解析")]),t._v(" "),a("p",[t._v("通过 DNS 预解析来告诉浏览器未来我们可能从某个特定的 URL 获取资源，当浏览器真正使用到该域中的某个资源时就可以尽快地完成 DNS 解析。")]),t._v(" "),a("p",[t._v("第一步：打开或关闭DNS预解析")]),t._v(" "),a("p",[t._v("你可以通过在服务器端发送 X-DNS-Prefetch-Control 报头。或是在文档中使用值为 http-equiv 的meta标签：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('\t<meta http-equiv="x-dns-prefetch-control" content="on">\n')])])]),a("p",[t._v("需要说明的是，在一些高级浏览器中，页面中所有的超链接（a标签），默认打开了DNS预解析。但是，如果页面中采用的https协议，很多浏览器是默认关闭了超链接的DNS预解析。如果加了上面这行代码，则表明强制打开浏览器的预解析。（如果你能在面试中把这句话说出来，则一定是你出彩的地方）")]),t._v(" "),a("p",[t._v("第二步：对指定的域名进行DNS预解析")]),t._v(" "),a("p",[t._v("如果我们将来可能从 smyhvae.com 获取图片或音频资源，那么可以在文档顶部的 标签中加入以下内容：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('\t<link rel="dns-prefetch" href="http://www.smyhvae.com/">\n')])])]),a("p",[t._v("当我们从该 URL 请求一个资源时，就不再需要等待 DNS 解析的过程。该技术对使用第三方资源特别有用。")]),t._v(" "),a("h2",{attrs:{id:"cdn"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cdn"}},[t._v("#")]),t._v(" CDN")]),t._v(" "),a("p",[t._v("怎么最快地让用户请求资源。一方面是让资源在传输的过程中变小，另外就是CDN。")]),t._v(" "),a("p",[t._v("要注意，浏览器第一次打开页面的时候，浏览器缓存是起不了作任何用的，使用CDN，效果就很明显。")]),t._v(" "),a("p",[t._v("其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。")]),t._v(" "),a("h2",{attrs:{id:"非核心代码异步加载"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#非核心代码异步加载"}},[t._v("#")]),t._v(" 非核心代码异步加载")]),t._v(" "),a("p",[t._v("异步加载主要有以下")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("动态脚本加载")])]),t._v(" "),a("li",[a("p",[t._v("defer")])]),t._v(" "),a("li",[a("p",[t._v("async")])])]),t._v(" "),a("p",[t._v("动态脚本加载")]),t._v(" "),a("p",[t._v("使用document.createElement创建一个script标签，即document.createElement('script')，然后把这个标签加载到body上面去。")]),t._v(" "),a("p",[t._v("defer")]),t._v(" "),a("p",[t._v("通过异步的方式加载defer1.js文件：")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("    "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("script src"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"./defer1.js"')]),t._v(" defer"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("script"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n")])])]),a("p",[t._v("async\nHTmL5新增特性。")]),t._v(" "),a("p",[t._v("通过异步的方式加载async1.js文件：")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("    "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("script src"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"./async1.js"')]),t._v(" async"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("script"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n")])])]),a("p",[t._v("defer和async的区别")]),t._v(" "),a("p",[t._v("defer：在HTML解析完之后才会执行。如果是多个，则按照加载的顺序依次执行。")]),t._v(" "),a("p",[t._v("async：在加载完之后立即执行。如果是多个，执行顺序和加载顺序无关。")]),t._v(" "),a("h2",{attrs:{id:"利用浏览器缓存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#利用浏览器缓存"}},[t._v("#")]),t._v(" 利用浏览器缓存")]),t._v(" "),a("p",[t._v("具体请参考"),a("RouterLink",{attrs:{to:"/student/aboutBrowser/3.html"}},[t._v("这里")])],1),t._v(" "),a("h2",{attrs:{id:"从js层面谈页面优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#从js层面谈页面优化"}},[t._v("#")]),t._v(" 从js层面谈页面优化")]),t._v(" "),a("ol",[a("li",[t._v("如果在解析HTML标记时，浏览器遇到了JavaScript，解析会停止。只有在该脚本执行完毕后，HTML渲染才会继续进行。所以这阻塞了页面的渲染。")])]),t._v(" "),a("p",[t._v("解决方法：在标签中使用 async或defer特性,或者将标签放在底部。")]),t._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[t._v("对DOM操作的代价是高昂的，这在网页应用中的通常是一个性能瓶颈。")])]),t._v(" "),a("p",[t._v("解决办法：修改和访问DOM元素会造成页面的Repaint和Reflow，循环对DOM操作更是罪恶的行为。所以请合理的使用JavaScript变量储存内容，考虑大量DOM元素中循环的性能开销，在循环结束时一次性写入。\n减少对DOM元素的查询和修改，查询时可将其赋值给局部变量。")]),t._v(" "),a("ol",{attrs:{start:"3"}},[a("li",[t._v("让需要经常改动的节点脱离文档流\n因为重绘有时确实不可避免，所以只能尽可能限制重绘的影响范围。")])]),t._v(" "),a("h2",{attrs:{id:"一些琐碎的知识点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一些琐碎的知识点"}},[t._v("#")]),t._v(" 一些琐碎的知识点")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("合法地去书写HTML和CSS ，且不要忘了文档编码类型。")])]),t._v(" "),a("li",[a("p",[t._v("DOM 的多个读操作（或多个写操作），应该放在一起。不要两个读操作之间，加入一个写操作。")])]),t._v(" "),a("li",[a("p",[t._v("如果某个样式是通过重排得到的，那么最好缓存结果。避免下一次用到的时候，浏览器又要重排。")])]),t._v(" "),a("li",[a("p",[t._v("不要一条条地改变样式，而要通过改变class，或者csstext属性，一次性地改变样式。")])]),t._v(" "),a("li",[a("p",[t._v("尽量用transform来做形变和位移")])]),t._v(" "),a("li",[a("p",[t._v("尽量使用离线DOM，而不是真实的网页DOM，来改变元素样式。比如，操作 "),a("strong",[t._v("Document Fragment")]),t._v(" 对象，完成后再把这个对象加入DOM。再比如，使用cloneNode()方法，在克隆的节点上进行操作，然后再用克隆的节点替换原始节点。")])]),t._v(" "),a("li",[a("p",[t._v("position属性为absolute或fixed的元素，重排的开销会比较小，因为不用考虑它对其他元素的影响。")])]),t._v(" "),a("li",[a("p",[t._v("只在必要的时候，才将元素的display属性为可见，因为不可见的元素不影响重排和重绘。另外，visibility : hidden的元素只对重绘有影响，不影响重排。")])]),t._v(" "),a("li",[a("p",[t._v("使用window.requestAnimationFrame()、window.requestIdleCallback()这两个方法调节重新渲染。")])])])])}),[],!1,null,null,null);s.default=e.exports}}]);