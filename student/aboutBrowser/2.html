<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>同源策略和跨域 | cc的学习笔记</title>
    <meta name="generator" content="VuePress 1.4.1">
    
    <meta name="description" content="我的博客">
    <meta name="theme-color" content="#3eaf7c">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="preload" href="/myblog/assets/css/0.styles.3e211e95.css" as="style"><link rel="preload" href="/myblog/assets/js/app.41615b56.js" as="script"><link rel="preload" href="/myblog/assets/js/2.814e5817.js" as="script"><link rel="preload" href="/myblog/assets/js/6.41cb4bea.js" as="script"><link rel="prefetch" href="/myblog/assets/js/10.ca316200.js"><link rel="prefetch" href="/myblog/assets/js/11.d8631f6b.js"><link rel="prefetch" href="/myblog/assets/js/12.a488b497.js"><link rel="prefetch" href="/myblog/assets/js/13.3cc6a402.js"><link rel="prefetch" href="/myblog/assets/js/14.c9a0d417.js"><link rel="prefetch" href="/myblog/assets/js/15.475a2b37.js"><link rel="prefetch" href="/myblog/assets/js/16.8a9137fb.js"><link rel="prefetch" href="/myblog/assets/js/17.9a7498ec.js"><link rel="prefetch" href="/myblog/assets/js/18.b5be574f.js"><link rel="prefetch" href="/myblog/assets/js/19.597126ba.js"><link rel="prefetch" href="/myblog/assets/js/20.839a0cd8.js"><link rel="prefetch" href="/myblog/assets/js/21.89da595b.js"><link rel="prefetch" href="/myblog/assets/js/22.90439cc7.js"><link rel="prefetch" href="/myblog/assets/js/23.ae6ca502.js"><link rel="prefetch" href="/myblog/assets/js/24.aaa25a26.js"><link rel="prefetch" href="/myblog/assets/js/25.18fef18d.js"><link rel="prefetch" href="/myblog/assets/js/26.d7948f7a.js"><link rel="prefetch" href="/myblog/assets/js/3.e7373026.js"><link rel="prefetch" href="/myblog/assets/js/4.3743e7be.js"><link rel="prefetch" href="/myblog/assets/js/5.f5e1ad52.js"><link rel="prefetch" href="/myblog/assets/js/7.dd730ae1.js"><link rel="prefetch" href="/myblog/assets/js/8.21240742.js"><link rel="prefetch" href="/myblog/assets/js/9.43ca0555.js">
    <link rel="stylesheet" href="/myblog/assets/css/0.styles.3e211e95.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/myblog/" class="home-link router-link-active"><!----> <span class="site-name">cc的学习笔记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/myblog/student/" class="nav-link router-link-active">
  笔记
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/myblog/student/" class="nav-link router-link-active">
  笔记
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>js进阶</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/myblog/student/jsProgress/1.html" class="sidebar-link">执行上下文相关</a></li><li><a href="/myblog/student/jsProgress/2.html" class="sidebar-link">异步编程</a></li><li><a href="/myblog/student/jsProgress/3.html" class="sidebar-link">原型与原型链</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>js性能与规范</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/myblog/student/jsPref/1.html" class="sidebar-link">js设计模式</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>浏览器相关知识</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/myblog/student/aboutBrowser/1.html" class="sidebar-link">从输入url到页面加载完成究竟发生了什么？</a></li><li><a href="/myblog/student/aboutBrowser/2.html" class="active sidebar-link">同源策略和跨域</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/myblog/student/aboutBrowser/2.html#基本概念" class="sidebar-link">基本概念</a></li><li class="sidebar-sub-header"><a href="/myblog/student/aboutBrowser/2.html#跨域资源共享（cors）" class="sidebar-link">跨域资源共享（CORS）</a></li><li class="sidebar-sub-header"><a href="/myblog/student/aboutBrowser/2.html#jsonp" class="sidebar-link">JSONP</a></li><li class="sidebar-sub-header"><a href="/myblog/student/aboutBrowser/2.html#通过修改document-domain来跨子域" class="sidebar-link">通过修改document.domain来跨子域</a></li><li class="sidebar-sub-header"><a href="/myblog/student/aboutBrowser/2.html#使用window-name来进行跨域" class="sidebar-link">使用window.name来进行跨域</a></li><li class="sidebar-sub-header"><a href="/myblog/student/aboutBrowser/2.html#使用html5的window-postmessage方法跨域" class="sidebar-link">使用HTML5的window.postMessage方法跨域</a></li><li class="sidebar-sub-header"><a href="/myblog/student/aboutBrowser/2.html#通过websocket进行跨域" class="sidebar-link">通过WebSocket进行跨域</a></li></ul></li><li><a href="/myblog/student/aboutBrowser/3.html" class="sidebar-link">浏览器缓存</a></li><li><a href="/myblog/student/aboutBrowser/4.html" class="sidebar-link">http请求协议相关</a></li><li><a href="/myblog/student/aboutBrowser/5.html" class="sidebar-link">浏览器渲染原理</a></li><li><a href="/myblog/student/aboutBrowser/sumUp.html" class="sidebar-link">页面性能优化相关</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>webpack</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/myblog/student/webpack/base.html" class="sidebar-link">webpack基本概念</a></li><li><a href="/myblog/student/webpack/1.html" class="sidebar-link">webpack基本配置</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="同源策略和跨域"><a href="#同源策略和跨域" class="header-anchor">#</a> 同源策略和跨域</h1> <p>知识点包括跨域方案以及为什么需要跨域等。</p> <h2 id="基本概念"><a href="#基本概念" class="header-anchor">#</a> 基本概念</h2> <ul><li>同源策略</li></ul> <p>简单来讲同源策略就是浏览器为了保证用户信息的安全，防止恶意的网站窃取数据，禁止不同域之间的JS进行交互。对于浏览器而言只要域名、协议、端口其中一个不同就会引发同源策略，从而限制他们之间如下的交互行为：</p> <ol><li><p>Cookie、LocalStorage和IndexDB无法读取；</p></li> <li><p>DOM无法获得；</p></li> <li><p>AJAX请求不能发送等等。</p></li></ol> <p>为什么浏览器要限制跨域访问呢？</p> <p>原因就是安全问题：如果一个网页可以随意地访问另外一个网站的资源，那么就有可能在客户完全不知情的情况下出现安全问题。比如下面的操作就有安全问题：</p> <p>用户访问www.mybank.com ，登陆并进行网银操作，这时cookie啥的都生成并存放在浏览器</p> <p>用户突然想起件事，并迷迷糊糊地访问了一个邪恶的网站 www.xiee.com</p> <p>这时该网站就可以在它的页面中，拿到银行的cookie，比如用户名，登陆token等，然后发起对www.mybank.com 的操作。</p> <p>如果这时浏览器不予限制，并且银行也没有做响应的安全处理的话，那么用户的信息有可能就这么泄露了。</p> <ul><li>跨域</li></ul> <p>跨域的严格一点的定义是：只要协议，域名，端口有任何一个的不同，就被当作是跨域。</p> <p>具体可以参考下图</p> <p><img src="/myblog/assets/img/item3.4d0abd24.jpg" alt=""></p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>第一，如果是协议和端口造成的跨域问题“前台”是无能为力的，</p> <p>第二：在跨域问题上，域仅仅是通过“URL的首部”来识别而不会去尝试判断相同的ip地址对应着两个域或两个域是否在同一个ip上。</p> <p>“URL的首部”指window.location.protocol +window.location.host，也可以理解为“Domains, protocols and ports must match”。</p></div> <p>接下来是跨域的几种方式</p> <h2 id="跨域资源共享（cors）"><a href="#跨域资源共享（cors）" class="header-anchor">#</a> 跨域资源共享（CORS）</h2> <p>CORS（Cross-Origin Resource Sharing）跨域资源共享，定义了必须在访问跨域资源时，浏览器与服务器应该如何沟通。CORS背后的基本思想就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是失败。</p> <p>服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。</p> <p>只需要在后台中加上响应头来允许域请求！在被请求的Response header中加入以下设置，就可以实现跨域访问了！</p> <p>如下所示：</p> <div class="language- extra-class"><pre class="language-text"><code>//指定允许其他域名访问
'Access-Control-Allow-Origin:*'//或指定域
//响应类型
'Access-Control-Allow-Methods:GET,POST'
//响应头设置
'Access-Control-Allow-Headers:x-requested-with,content-type'
</code></pre></div><h2 id="jsonp"><a href="#jsonp" class="header-anchor">#</a> JSONP</h2> <p>JSONP的原理：通过script标签引入一个js文件，这个js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。所以jsonp是需要服务器端的页面进行相应的配合的。（即用JavaScript动态加载一个script文件，同时定义一个callback函数给script执行而已。）</p> <p>在js中，我们直接用XMLHttpRequest请求不同域上的数据时，是不可以的。但是，在页面上引入不同域上的js脚本文件却是可以的，jsonp正是利用这个特性来实现的。 例如：有个a.html页面，它里面的代码需要利用ajax获取一个不同域上的json数据，假设这个json数据地址是http://example.com/data.php，那么a.html中的代码就可以这样：</p> <div class="language-js extra-class"><pre class="language-js"><code>​<span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">&quot;text/javascript&quot;</span><span class="token operator">&gt;</span>
 <span class="token keyword">function</span> <span class="token function">dosomething</span><span class="token punctuation">(</span><span class="token parameter">jsondata</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
     <span class="token comment">//处理获得的json数据</span>
 <span class="token punctuation">}</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">&quot;http://example.com/data.php?callback=dosomething&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
</code></pre></div><p>js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。所以jsonp是需要服务器端的页面进行相应的配合的。</p> <div class="language-php extra-class"><pre class="language-php"><code>​   <span class="token php language-php"><span class="token delimiter important">&lt;?php</span>
<span class="token variable">$callback</span> <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token single-quoted-string string">'callback'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//得到回调函数名</span>
<span class="token variable">$data</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token single-quoted-string string">'a'</span><span class="token punctuation">,</span><span class="token single-quoted-string string">'b'</span><span class="token punctuation">,</span><span class="token single-quoted-string string">'c'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//要返回的数据</span>
<span class="token keyword">echo</span> <span class="token variable">$callback</span><span class="token punctuation">.</span><span class="token single-quoted-string string">'('</span><span class="token punctuation">.</span><span class="token function">json_encode</span><span class="token punctuation">(</span><span class="token variable">$data</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token single-quoted-string string">')'</span><span class="token punctuation">;</span><span class="token comment">//输出</span>
<span class="token delimiter important">?&gt;</span></span>
</code></pre></div><p>最终，输出结果为：dosomething(['a','b','c']);</p> <p><strong>JSONP的优缺点</strong>：</p> <p>JSONP的 <strong>优点</strong> 是：它不像XMLHttpRequest对象实现的Ajax请求那样受到同源策略的限制；它的兼容性更好，在更加古老的浏览器中都可以运行，不需要XMLHttpRequest或ActiveX的支持；并且在请求完毕后可以通过调用callback的方式回传结果。</p> <p>JSONP的 <strong>缺点</strong> 则是：它只支持GET请求而不支持POST等其它类型的HTTP请求；它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行JavaScript调用的问题。</p> <p><strong>CORS和JSONP对比</strong>：</p> <p>CORS与JSONP相比，无疑更为先进、方便和可靠。</p> <p>（1）JSONP只能实现GET请求，而CORS支持所有类型的HTTP请求；</p> <p>（2）使用CORS，开发者可以使用普通的XMLHttpRequest发起请求和获得说句，比起JSONP有更好的错误处理；</p> <p>（3）JSONP主要被老的浏览器支持，它们往往不支持CORS，而绝大多数现代浏览器都已经支持了CORS；</p> <h2 id="通过修改document-domain来跨子域"><a href="#通过修改document-domain来跨子域" class="header-anchor">#</a> 通过修改document.domain来跨子域</h2> <p>上面的jsonp是来解决ajax跨域请求的，那么如果是需要处理 Cookie 和 iframe 该怎么办呢？这时候就可以通过修改document.domain来跨子域。两个网页一级域名相同，只是二级域名不同，浏览器允许通过设置document.domain共享 Cookie或者处理iframe。比如A网页是http://w1.example.com/a.html，B网页是http://w2.example.com/b.html，那么只要设置相同的document.domain，两个网页就可以共享Cookie。</p> <div class="language-js extra-class"><pre class="language-js"><code>​   document<span class="token punctuation">.</span>domain <span class="token operator">=</span> <span class="token string">'example.com'</span><span class="token punctuation">;</span>
<span class="token comment">//现在，A网页通过脚本设置一个 Cookie。</span>
document<span class="token punctuation">.</span>cookie <span class="token operator">=</span> <span class="token string">&quot;test1=hello&quot;</span><span class="token punctuation">;</span>
<span class="token comment">//B网页就可以读到这个 Cookie。</span>
</code></pre></div><p>注意，这种方法只适用于 Cookie 和 iframe 窗口，LocalStorage 和 IndexDB 无法通过这种方法，规避同源政策，而要使用下文介绍的PostMessage API。</p> <p>另外，服务器也可以在设置Cookie的时候，指定Cookie的所属域名为一级域名，比如.example.com。</p> <div class="language- extra-class"><pre class="language-text"><code>Set-Cookie: key=value; domain=.example.com; path=/
//这样的话，二级域名和三级域名不用做任何设置，都可以读取这个Cookie。
</code></pre></div><p>不同的iframe 之间（父子或同辈），是能够获取到彼此的window对象的，但是你却不能使用获取到的window对象的属性和方法(html5中的postMessage方法是一个例外，还有些浏览器比如ie6也可以使用top、parent等少数几个属性)，总之，你可以当做是只能获取到一个几乎无用的window对象。</p> <p>首先说明一下同域之间的iframe是可以操作的。比如http://127.0.0.1/JSONP/a.html里面嵌入一个iframe指向http://127.0.0.1/myPHP/b.html。那么在a.html里面是可以操作iframe里面的DOM的。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>iframe src<span class="token operator">=</span><span class="token string">&quot;http://127.0.0.1/myPHP/b.html&quot;</span> frameborder<span class="token operator">=</span><span class="token string">&quot;1&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>iframe<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>body<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">&quot;text/javascript&quot;</span><span class="token operator">&gt;</span>
<span class="token keyword">var</span> iframe <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">&quot;iframe&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
iframe<span class="token punctuation">.</span><span class="token function-variable function">onload</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">var</span> win <span class="token operator">=</span> iframe<span class="token punctuation">.</span>contentWindow<span class="token punctuation">;</span>
    <span class="token keyword">var</span> doc <span class="token operator">=</span> win<span class="token punctuation">.</span>document<span class="token punctuation">;</span>
    <span class="token keyword">var</span> ele <span class="token operator">=</span> doc<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">&quot;.text1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> text <span class="token operator">=</span> ele<span class="token punctuation">.</span>innerHTML<span class="token operator">=</span><span class="token string">&quot;123456&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
</code></pre></div><p>如果两个网页不同源，就无法拿到对方的DOM。典型的例子是iframe窗口和window.open方法打开的窗口，它们与父窗口无法通信。如果两个窗口一级域名相同，只是二级域名不同，那么document.domain属性，就可以规避同源政策，拿到DOM。</p> <h2 id="使用window-name来进行跨域"><a href="#使用window-name来进行跨域" class="header-anchor">#</a> 使用window.name来进行跨域</h2> <p>window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。这个属性的最大特点是，无论是否同源，只要在同一个窗口里，前一个网页设置了这个属性，后一个网页可以读取它。 
比如：有一个页面a.html,它里面有这样的代码：</p> <div class="language-js extra-class"><pre class="language-js"><code>window<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;我是a页面设置的&quot;</span><span class="token punctuation">;</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    window<span class="token punctuation">.</span>location <span class="token operator">=</span> <span class="token string">&quot;http://127.0.0.1/JSONP/b.html&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span>
</code></pre></div><p>b.html页面的代码：</p> <div class="language-js extra-class"><pre class="language-js"><code>​console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>a.html页面载入后1秒，跳转到了b.html页面，结果b页面打印出了：</p> <div class="language- extra-class"><pre class="language-text"><code>   我是a页面设置的
</code></pre></div><p>可以看到在b.html页面上成功获取到了它的上一个页面a.html给window.name设置的值。如果在之后所有载入的页面都没对window.name进行修改的话，那么所有这些页面获取到的window.name的值都是a.html页面设置的那个值。当然，如果有需要，其中的任何一个页面都可以对window.name的值进行修改。注意，window.name的值只能是字符串的形式，这个字符串的大小最大能允许2M左右甚至更大的一个容量，具体取决于不同的浏览器，但一般是够用了。
 
利用window.name可以对同域或者不同域的之间的js进行交互。</p> <p>那么在a.html页面中，我们怎么把b.html页面载入进来呢？显然我们不能直接在a.html页面中通过改变window.location来载入b.html页面，因为我们想要即使a.html页面不跳转也能得到b.html里的数据。答案就是在a.html页面中使用一个隐藏的iframe来充当一个中间人角色，由iframe去获取b.html的数据，然后a.html再去得到iframe获取到的数据。</p> <h2 id="使用html5的window-postmessage方法跨域"><a href="#使用html5的window-postmessage方法跨域" class="header-anchor">#</a> 使用HTML5的window.postMessage方法跨域</h2> <p>上面两种方法都属于破解，HTML5为了解决这个问题，引入了一个全新的API：跨文档通信 API（Cross-document messaging）。</p> <p>这个API为window对象新增了一个window.postMessage方法，允许跨窗口通信，不论这两个窗口是否同源。目前IE8+、FireFox、Chrome、Opera等浏览器都已经支持window.postMessage方法。</p> <p>举例来说，父窗口http://a.com向子窗口http://b.com发消息，调用postMessage方法就可以了。</p> <p>a页面：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>iframe id<span class="token operator">=</span><span class="token string">&quot;frame1&quot;</span> src<span class="token operator">=</span><span class="token string">&quot;http://127.0.0.1/JSONP/b.html&quot;</span> frameborder<span class="token operator">=</span><span class="token string">&quot;1&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>iframe<span class="token operator">&gt;</span>
document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'frame1'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function-variable function">onload</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">var</span> win <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'frame1'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>contentWindow<span class="token punctuation">;</span>
    win<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span><span class="token string">&quot;我是来自a页面的&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;http://127.0.0.1/JSONP/b.html&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
b页面通过监听message事件可以接受到来自a页面的消息。

window<span class="token punctuation">.</span><span class="token function-variable function">onmessage</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    e <span class="token operator">=</span> e <span class="token operator">||</span> event<span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//我是来自a页面的</span>
<span class="token punctuation">}</span>
</code></pre></div><p>子窗口向父窗口发送消息的写法类似。</p> <div class="language-js extra-class"><pre class="language-js"><code>window<span class="token punctuation">.</span>opener<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span><span class="token string">'我是来自b页面的'</span><span class="token punctuation">,</span> <span class="token string">'http://a.com'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//父窗口和子窗口都可以通过message事件，监听对方的消息。</span>
</code></pre></div><p>通过window.postMessage，读写其他窗口的 LocalStorage 也成为了可能。 
下面是一个例子，主窗口写入iframe子窗口的localStorage。 
父窗口发送消息代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> win <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">'iframe'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>contentWindow<span class="token punctuation">;</span>
<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">'Jack'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// 存入对象</span>
win<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span><span class="token punctuation">{</span>key<span class="token operator">:</span> <span class="token string">'storage'</span><span class="token punctuation">,</span> method<span class="token operator">:</span> <span class="token string">'set'</span><span class="token punctuation">,</span> data<span class="token operator">:</span> obj<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'http://b.com'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 读取对象</span>
win<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span><span class="token punctuation">{</span>key<span class="token operator">:</span> <span class="token string">'storage'</span><span class="token punctuation">,</span> method<span class="token operator">:</span> <span class="token string">&quot;get&quot;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">&quot;*&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
window<span class="token punctuation">.</span><span class="token function-variable function">onmessage</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>origin <span class="token operator">!=</span> <span class="token string">'http://a.com'</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token comment">// &quot;Jack&quot;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>子窗口接收消息的代码：</p> <div class="language-js extra-class"><pre class="language-js"><code>window<span class="token punctuation">.</span><span class="token function-variable function">onmessage</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>origin <span class="token operator">!==</span> <span class="token string">'http://bbb.com'</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> payload <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">switch</span> <span class="token punctuation">(</span>payload<span class="token punctuation">.</span>method<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> <span class="token string">'set'</span><span class="token operator">:</span>
      localStorage<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span>payload<span class="token punctuation">.</span>key<span class="token punctuation">,</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>payload<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> <span class="token string">'get'</span><span class="token operator">:</span>
      <span class="token keyword">var</span> parent <span class="token operator">=</span> window<span class="token punctuation">.</span>parent<span class="token punctuation">;</span>
      <span class="token keyword">var</span> data <span class="token operator">=</span> localStorage<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span>payload<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
      parent<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token string">'http://aaa.com'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> <span class="token string">'remove'</span><span class="token operator">:</span>
      localStorage<span class="token punctuation">.</span><span class="token function">removeItem</span><span class="token punctuation">(</span>payload<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="通过websocket进行跨域"><a href="#通过websocket进行跨域" class="header-anchor">#</a> 通过WebSocket进行跨域</h2> <p>web sockets是一种浏览器的API，它的目标是在一个单独的持久连接上提供全双工、双向通信。(同源策略对web sockets不适用)</p> <p>web sockets原理：在js创建了web socket之后，会有一个HTTP请求发送到浏览器以发起连接。取得服务器响应后，建立的连接会使用HTTP升级从HTTP协议交换为web sockt协议。</p> <p>只有在支持web socket协议的服务器上才能正常工作。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> socket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WebSockt</span><span class="token punctuation">(</span><span class="token string">'ws://www.baidu.com'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//http-&gt;ws; https-&gt;wss</span>
socket<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">'hello WebSockt'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
socket<span class="token punctuation">.</span><span class="token function-variable function">onmessage</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">var</span> data <span class="token operator">=</span> event<span class="token punctuation">.</span>data<span class="token punctuation">;</span>
</code></pre></div><hr> <hr> <p>还有图像ping和片段识别符等方法这边不具体做介绍了，如果感兴趣可以参考<a href="https://blog.csdn.net/lareinalove/article/details/84107476" target="_blank" rel="noopener noreferrer">这里<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/myblog/student/aboutBrowser/1.html" class="prev">
        从输入url到页面加载完成究竟发生了什么？
      </a></span> <span class="next"><a href="/myblog/student/aboutBrowser/3.html">
        浏览器缓存
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/myblog/assets/js/app.41615b56.js" defer></script><script src="/myblog/assets/js/2.814e5817.js" defer></script><script src="/myblog/assets/js/6.41cb4bea.js" defer></script>
  </body>
</html>
