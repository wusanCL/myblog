<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>执行上下文相关 | cc的学习笔记</title>
    <meta name="generator" content="VuePress 1.4.1">
    
    <meta name="description" content="我的博客">
    <meta name="theme-color" content="#3eaf7c">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="preload" href="/myblog/assets/css/0.styles.3e211e95.css" as="style"><link rel="preload" href="/myblog/assets/js/app.41615b56.js" as="script"><link rel="preload" href="/myblog/assets/js/2.814e5817.js" as="script"><link rel="preload" href="/myblog/assets/js/20.839a0cd8.js" as="script"><link rel="prefetch" href="/myblog/assets/js/10.ca316200.js"><link rel="prefetch" href="/myblog/assets/js/11.d8631f6b.js"><link rel="prefetch" href="/myblog/assets/js/12.a488b497.js"><link rel="prefetch" href="/myblog/assets/js/13.3cc6a402.js"><link rel="prefetch" href="/myblog/assets/js/14.c9a0d417.js"><link rel="prefetch" href="/myblog/assets/js/15.475a2b37.js"><link rel="prefetch" href="/myblog/assets/js/16.8a9137fb.js"><link rel="prefetch" href="/myblog/assets/js/17.9a7498ec.js"><link rel="prefetch" href="/myblog/assets/js/18.b5be574f.js"><link rel="prefetch" href="/myblog/assets/js/19.597126ba.js"><link rel="prefetch" href="/myblog/assets/js/21.89da595b.js"><link rel="prefetch" href="/myblog/assets/js/22.90439cc7.js"><link rel="prefetch" href="/myblog/assets/js/23.ae6ca502.js"><link rel="prefetch" href="/myblog/assets/js/24.aaa25a26.js"><link rel="prefetch" href="/myblog/assets/js/25.18fef18d.js"><link rel="prefetch" href="/myblog/assets/js/26.d7948f7a.js"><link rel="prefetch" href="/myblog/assets/js/3.e7373026.js"><link rel="prefetch" href="/myblog/assets/js/4.3743e7be.js"><link rel="prefetch" href="/myblog/assets/js/5.f5e1ad52.js"><link rel="prefetch" href="/myblog/assets/js/6.41cb4bea.js"><link rel="prefetch" href="/myblog/assets/js/7.dd730ae1.js"><link rel="prefetch" href="/myblog/assets/js/8.21240742.js"><link rel="prefetch" href="/myblog/assets/js/9.43ca0555.js">
    <link rel="stylesheet" href="/myblog/assets/css/0.styles.3e211e95.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/myblog/" class="home-link router-link-active"><!----> <span class="site-name">cc的学习笔记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/myblog/student/" class="nav-link router-link-active">
  笔记
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/myblog/student/" class="nav-link router-link-active">
  笔记
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>js进阶</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/myblog/student/jsProgress/1.html" class="active sidebar-link">执行上下文相关</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/myblog/student/jsProgress/1.html#基本概念" class="sidebar-link">基本概念</a></li><li class="sidebar-sub-header"><a href="/myblog/student/jsProgress/1.html#执行上下文类型" class="sidebar-link">执行上下文类型</a></li><li class="sidebar-sub-header"><a href="/myblog/student/jsProgress/1.html#执行栈" class="sidebar-link">执行栈</a></li><li class="sidebar-sub-header"><a href="/myblog/student/jsProgress/1.html#执行上下文的2个阶段" class="sidebar-link">执行上下文的2个阶段</a></li><li class="sidebar-sub-header"><a href="/myblog/student/jsProgress/1.html#变量对象" class="sidebar-link">变量对象</a></li><li class="sidebar-sub-header"><a href="/myblog/student/jsProgress/1.html#活动对象" class="sidebar-link">活动对象</a></li><li class="sidebar-sub-header"><a href="/myblog/student/jsProgress/1.html#作用域链" class="sidebar-link">作用域链</a></li><li class="sidebar-sub-header"><a href="/myblog/student/jsProgress/1.html#闭包" class="sidebar-link">闭包</a></li><li class="sidebar-sub-header"><a href="/myblog/student/jsProgress/1.html#this指针" class="sidebar-link">This指针</a></li></ul></li><li><a href="/myblog/student/jsProgress/2.html" class="sidebar-link">异步编程</a></li><li><a href="/myblog/student/jsProgress/3.html" class="sidebar-link">原型与原型链</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>js性能与规范</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/myblog/student/jsPref/1.html" class="sidebar-link">js设计模式</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>浏览器相关知识</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/myblog/student/aboutBrowser/1.html" class="sidebar-link">从输入url到页面加载完成究竟发生了什么？</a></li><li><a href="/myblog/student/aboutBrowser/2.html" class="sidebar-link">同源策略和跨域</a></li><li><a href="/myblog/student/aboutBrowser/3.html" class="sidebar-link">浏览器缓存</a></li><li><a href="/myblog/student/aboutBrowser/4.html" class="sidebar-link">http请求协议相关</a></li><li><a href="/myblog/student/aboutBrowser/5.html" class="sidebar-link">浏览器渲染原理</a></li><li><a href="/myblog/student/aboutBrowser/sumUp.html" class="sidebar-link">页面性能优化相关</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>webpack</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/myblog/student/webpack/base.html" class="sidebar-link">webpack基本概念</a></li><li><a href="/myblog/student/webpack/1.html" class="sidebar-link">webpack基本配置</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="执行上下文相关"><a href="#执行上下文相关" class="header-anchor">#</a> 执行上下文相关</h1> <p>包含了变量对象、活动对象、作用域链、闭包、this指针等相关知识。</p> <h2 id="基本概念"><a href="#基本概念" class="header-anchor">#</a> 基本概念</h2> <p>执行上下文是当前代码被解析和执行时所在环境的一个抽象的概念。每一种代码的执行都需要依赖自身的上下文，在js中，只有3中类型，global、eval、function。</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>一个function可能产生无限的上下文环境，因为一个函数的调用（甚至递归）都产生一个新的上下文环境。</p></div> <p>每一个执行的上下文，可以抽象的理解成一个obj，每个执行上下文都有一些属性，一般称之为上下文状态，包含变量对象、this指向、作用域链。</p> <h2 id="执行上下文类型"><a href="#执行上下文类型" class="header-anchor">#</a> 执行上下文类型</h2> <p>上面说到js中执行上下文有3种</p> <ul><li>global，只有一个，在浏览器中，global就是window对象，当然golbal的上下文可能涵盖了很多的function和eval的实例。</li> <li>function，函数函数的每一次调用，都会创建一个新的执行上下文，当函数执行完毕时删除。</li> <li>eval，即在eval中执行的代码，每一次执行也会进入eval执行中的上下文，不建议使用，这边也不过多讲解。</li></ul> <h2 id="执行栈"><a href="#执行栈" class="header-anchor">#</a> 执行栈</h2> <p>一个执行上下文可以激活另一个上下文，就好比一个函数调用了另一个函数，然后一层一层调用下去。逻辑上来说，这种实现方式是栈，我们可以称之为上下文堆栈。
执行栈具有 LIFO（后进先出）结构，存储着代码执行期间创建的所有执行上下文。</p> <p>激活其它上下文的某个上下文被称为 调用者(caller) 。被激活的上下文被 称为被调用者(callee) 。被调用者同时也可能是调用者(比如一个在全局上下文中被调用的函数调用某些自身的内部方法)。</p> <p>当一个caller激活了一个callee，那么这个caller就会暂停它自身的执行，然后将控制权交给这个callee. 于是这个callee被放入堆栈，称为进行中的上下文[running/active execution context]. 当这个callee的上下文结束之后，会把控制权再次交给它的caller，然后caller会在刚才暂停的地方继续执行。在这个caller结束之后，会继续触发其他的上下文。一个callee可以用return或者抛出异常来结束自身的上下文。</p> <p>首次运行js代码时，会创建一个global上下文并Push到当前的执行栈中。每当发生函数调用，引擎都会创建一个该函数的执行上下文并Push到执行栈中。在函数执行完毕以后再Pop出。</p> <h2 id="执行上下文的2个阶段"><a href="#执行上下文的2个阶段" class="header-anchor">#</a> 执行上下文的2个阶段</h2> <p>执行上下文的代码被分成两个基本的阶段来进行处理：</p> <ul><li>进入执行上下文</li> <li>执行代码</li></ul> <p>在进入执行上下文时，VO（变量对象）已经包含以下属性了</p> <ul><li>函数的所有形参(如果我们是在函数执行上下文中)</li></ul> <p>由名称和对应值组成的一个变量对象的属性被创建；没有传递对应参数的话，那么由名称和undefined值组成的一种变量对象的属性也将被创建。</p> <ul><li>所有函数声明(FunctionDeclaration, FD)</li></ul> <p>由名称和对应值（函数对象(function-object)）组成一个变量对象的属性被创建；如果变量对象已经存在相同名称的属性，则完全替换这个属性。</p> <ul><li>所有变量声明(var, VariableDeclaration)</li></ul> <p>由名称和对应值（undefined）组成一个变量对象的属性被创建；如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性。</p> <p>这也就是变量提升和声明提升的原理。</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <div class="language- extra-class"><pre><code>  注意这边的变量提升，变量的定义是：只能使用var关键字声明（当然es6有新增就是）。
  也就是说，如果不使用var关键字，声明的是全局对象的属性，不具有变量提升的特性。
  同时，变量不可以被delete，你可以试试var变量，然后delete全局对象的这个变量。
</code></pre></div></div> <p>代码执行</p> <p>这个时候对应的AO/VO已经拥有了属性，不过大部分的属性没有值。这边要注意声明提升和变量提升的一个优先级。以下是一个很经典的例子</p> <div class="language-js extra-class"><pre class="language-js"><code> <span class="token function">alert</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// function</span>

 <span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
 <span class="token function">alert</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 10</span>
 
 x <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
 
 <span class="token keyword">function</span> <span class="token function">x</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
 
 <span class="token function">alert</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 20</span>
</code></pre></div><h2 id="变量对象"><a href="#变量对象" class="header-anchor">#</a> 变量对象</h2> <p>变量对象(VO) 是与执行上下文相关的 数据作用域。它是与上下文关联的特殊对象，用于存储被定义在上下文中的变量和函数声明。</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>函数表达式是不包含在VO里面的。或者说，函数表达式在代码执行阶段之前，是一个变量声明，只有在执行阶段才会真正的赋值。</p></div> <p>让我来看下实际代码:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// // 函数声明</span>
<span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">baz</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 函数表达式</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>foo <span class="token operator">==</span> foo<span class="token punctuation">,</span> <span class="token comment">// true</span>
  window<span class="token punctuation">.</span>bar <span class="token operator">==</span> bar <span class="token comment">// true</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>baz<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 引用错误，baz没有被定义</span>
</code></pre></div><p>这时候的全局上下文的VO具有如下属性</p> <table><thead><tr><th>key</th> <th>value</th></tr></thead> <tbody><tr><td>foo</td> <td>10</td></tr> <tr><td>bar</td> <td>function</td></tr></tbody></table> <p>如上所示，函数baz作为函数表达式并不被包含在VO中。所以外部访问不到。</p> <h2 id="活动对象"><a href="#活动对象" class="header-anchor">#</a> 活动对象</h2> <p>当函数被调用的时候，会创建一个特殊的活动对象。相比变量对象，它还包含了形参和一个特殊对象arguments。活动对象在函数上下文中作为变量对象使用。</p> <h2 id="作用域链"><a href="#作用域链" class="header-anchor">#</a> 作用域链</h2> <p>作用域链是一个对象列表，用以检索上下文代码中出现的标识符。
标识符可以理解为变量名称，函数声明和普通参数。例如：当一个函数在自身函数体内需要引用一个变量，但是这个变量并没有在函数内部声明，那么这个变量就可以称为自由变量。那么我们搜寻这些自由变量就需要用到作用域链。</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <div class="language- extra-class"><pre><code>  自由变量指在函数中使用的，但既不是参数，也不是局部变量的变量。
  不存在当前活动对象的变量。
  简单来说就是别的函数的变量。
</code></pre></div></div> <p>作用域链的创建时间是在执行上下文创建的时候，由当前的活动对象加上一个内部属性'[[scope]]'组成。这个属性包含了父级的层级链，也就是父级的所有变量对象（活动对象），这个内部属性的创建时期是函数声明的时候，也就是说作用域链和函数的声明位置有关。</p> <p>在代码执行过程中，如果使用with或者catch语句就会改变作用域链。碰上这种情况，作用域链会从两个维度来搜寻。</p> <p>还有一个特殊情况，使用Function构造函数创建的函数的[[scope]]属性总是唯一的全局对象。</p> <h3 id="作用域链的二维查找"><a href="#作用域链的二维查找" class="header-anchor">#</a> 作用域链的二维查找</h3> <p>要注意js的原型特性，你所声明的变量和函数等等其实可以看做当前变量对象的属性，也就是说查询标识符的时候会往原型链上查找。</p> <p>活动对象没有原型。但是，window有。</p> <h2 id="闭包"><a href="#闭包" class="header-anchor">#</a> 闭包</h2> <p>从理论角度来说，所有的函数都是闭包，前面说到，函数创建的时候就已经将父级的层级链保存下来了。
不过从实践角度来说，要满足以下条件才是闭包</p> <ul><li>即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）</li> <li>在代码中引用了自由变量</li></ul> <p>闭包中的变量存储在堆内存中而不是栈内存。具体原理这边不多说，如果想了解可以查看<a href="https://www.cnblogs.com/TomXu/archive/2012/01/31/2330252.html" target="_blank" rel="noopener noreferrer">此链接<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <div class="language- extra-class"><pre><code> 要注意，几个函数可能含有相同的父级作用域，也就是说在[[scope]]中存在的变量是会共享的。
 其实这种情况很常见，比如全局变量什么的。
</code></pre></div></div> <h2 id="this指针"><a href="#this指针" class="header-anchor">#</a> This指针</h2> <p>注：这边从一个比较粗浅容易理解的方式讲解，如果想要深入底层可以查看<a href="https://www.cnblogs.com/TomXu/archive/2012/01/17/2310479.html" target="_blank" rel="noopener noreferrer">此链接<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>简单来说this指针绑定分5种情况：</p> <ul><li>默认绑定</li> <li>隐式绑定</li> <li>显示绑定</li> <li>new绑定</li> <li>箭头函数绑定</li></ul> <h3 id="默认绑定"><a href="#默认绑定" class="header-anchor">#</a> 默认绑定</h3> <p>独立函数调用，可以把默认绑定看作是无法应用其它规则时的默认规则，非严格模式下this绑定到window，在严格模式下，则为undefined</p> <h3 id="隐式绑定"><a href="#隐式绑定" class="header-anchor">#</a> 隐式绑定</h3> <p>当函数引用有上下文对象时，会将this绑定到这个对象上。</p> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>

 <span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
     a<span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
     foo<span class="token operator">:</span> foo
 <span class="token punctuation">}</span><span class="token punctuation">;</span>

 obj<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>
</code></pre></div><p>要注意有种隐式丢失的情况,比如参数传递、callback等等。</p> <div class="language-js extra-class"><pre class="language-js"><code> <span class="token comment">// 虽然bar是obj.foo的一个引用，但是实际上，它引用的是foo函数本身。</span>
 <span class="token comment">// bar()是一个不带任何修饰的函数调用，应用默认绑定。</span>
 <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>

 <span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
     a<span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
     foo<span class="token operator">:</span> foo
 <span class="token punctuation">}</span><span class="token punctuation">;</span>

 <span class="token keyword">var</span> bar <span class="token operator">=</span> obj<span class="token punctuation">.</span>foo<span class="token punctuation">;</span> <span class="token comment">// 函数别名</span>

 <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">&quot;oops, global&quot;</span><span class="token punctuation">;</span> <span class="token comment">// a是全局对象的属性</span>

 <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;oops, global&quot;</span>
</code></pre></div><h3 id="显示绑定"><a href="#显示绑定" class="header-anchor">#</a> 显示绑定</h3> <p>通过call和apply方法或者bind方法进行调用。如果使用这些方法你传入的是bull或者undefined，那么应用的就是默认规则，也就是绑定到window上。</p> <h3 id="new绑定"><a href="#new绑定" class="header-anchor">#</a> new绑定</h3> <p>使用new来调用函数会发生以下操作：</p> <ul><li>创建（或者说构造）一个新对象。</li> <li>这个新对象会被执行[[Prototype]]连接。</li> <li>这个新对象会绑定到函数调用的this。</li> <li>如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。</li></ul> <p>我们可以模拟一个new</p> <div class="language-js extra-class"><pre class="language-js"><code> <span class="token keyword">function</span> <span class="token function">demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token comment">// 创建一个空的对象</span>
 <span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
     Pro <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 获得构造函数，arguments中去除第一个参数      </span>
 <span class="token comment">// 链接到原型，obj 可以访问到构造函数原型中的属性</span>
 obj<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> <span class="token class-name">Pro</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>
 <span class="token comment">// 绑定 this 实现继承，obj 可以访问到构造函数中的属性</span>
 <span class="token keyword">var</span> ret <span class="token operator">=</span> <span class="token function">Pro</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token comment">// 优先返回构造函数返回的对象</span>
 <span class="token keyword">return</span> ret <span class="token keyword">instanceof</span> <span class="token class-name">Object</span> <span class="token operator">?</span> ret <span class="token operator">:</span> obj<span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="箭头函数绑定"><a href="#箭头函数绑定" class="header-anchor">#</a> 箭头函数绑定</h3> <p>箭头函数的this依赖外层作用域来指定this，this无法直接更改，可间接更改(修改父级作用域)。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><!----> <span class="next"><a href="/myblog/student/jsProgress/2.html">
        异步编程
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/myblog/assets/js/app.41615b56.js" defer></script><script src="/myblog/assets/js/2.814e5817.js" defer></script><script src="/myblog/assets/js/20.839a0cd8.js" defer></script>
  </body>
</html>
